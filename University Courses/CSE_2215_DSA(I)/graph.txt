Graph
-----------



DFS
---------
dfs(Graph[][],u,visited[]){
	visited[u] <- true
	for each V of Graph[u]
		if visited[V] = false
			dfs(Graph, V, visited)
}



DFS Cycle Detection
-----------------------
dfs_cycle(Graph[][], u, visited[], parent){
	visited[u] <- true
	for each child V of Graph[u]
		if visited[V] = false
			if dfs(Graph, V, visited, u) = true 
				return true
		else if u != parent
			return true
	return false
}			




BFS
-------------
bfs(Graph[][],source, visited[]){
	queue q;
	q.enqueue(source)
	visited[source] = true
	while q is not empty :
		current = q.front()
		q.dequeue()
		for each friend in Graph[current]:
			if visited[friend] = false
				visited[friend] = true
				q.enqueue(friend)
			
}


BFS Shortest Path
----------------------
bfs_shortestPath(Graph[][],source, visited[], distance[]){ 
	queue q;
	q.enqueue(source)
	visited[source] = true
	while q is not empty :
		current = q.front()
		q.dequeue()
		for each friend in Graph[current]:
			if visited[friend] = false
				visited[friend] = true
				distance[friend] = distance[current] + 1
				q.enqueue(friend)
			
}



Topological Sort
--------------------------

topological_sort(Graph){
	stack S
	for each u(vertex) of Graph 
		indegree[u] = indeg(u)
		if indegree[u] = 0 
			S.push(u)
	while S is not empty:
		v = S.pop()
		print(v)
		for each u(out_vertex) of v do:
			indegree[u]--
			if indegree[u] = 0 do
				S.push(u)
			
}
