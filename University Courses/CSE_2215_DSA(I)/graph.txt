Graph
-----------



DFS
---------
dfs(Graph[][],u,visited[]){
	visited[u] <- true
	for each V of Graph[u]
		if visited[V] = false
			dfs(Graph, V, visited)
}



DFS Cycle Detection
-----------------------
dfs_cycle(Graph[][], u, visited[], parent){
	visited[u] <- true
	for each child of Graph[u]
		if visited[V] = false
			if dfs(Graph, V, visited, u) = true 
				return true
		else if u != parent
			return true
	return false
}			




BFS
-------------
bfs(Graph[][],source, visited[]){
	queue q;
	q.enqueue(source)
	visited[source] = true
	while q is not empty :
		current = q.front()
		q.dequeue()
		for each friend in Graph[current]:
			if visited[friend] = false
				visited[friend] = true
				q.enqueue(friend)
			
}


BFS Shortest Path
----------------------
bfs_shortestPath(Graph[][],source, visited[], distance[]){ 
	queue q;
	q.enqueue(source)
	visited[source] = true
	while q is not empty :
		current = q.front()
		q.dequeue()
		for each friend in Graph[current]:
			if visited[friend] = false
				visited[friend] = true
				distance[friend] = distance[current] + 1
				q.enqueue(friend)
			
}




